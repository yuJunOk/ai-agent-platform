# <font style="color:rgb(51, 51, 51);">Redis 中常见的数据类型有哪些？</font>
<font style="color:rgb(51, 51, 51);">Redis常见的数据类型主要有5种。</font>

1. <font style="color:rgb(51, 51, 51);">string：最常用的，value可以是字符、整数、浮点等。主要用于存储分布式ID和Token的场景。</font>
2. <font style="color:rgb(51, 51, 51);">hash：hash是一个filed-value的结构，能单独对filed进行修改。适合键值对的场景，例如缓存一些统计数据，并且可以单独进行统计数据操作。</font>
3. <font style="color:rgb(51, 51, 51);">list：list是一个有序列表，元素可以重复，可以做有序列表的缓存，可以通过blpop、brpop做简单的分布式阻塞队列。</font>
4. <font style="color:rgb(51, 51, 51);">set：set是一个无序集合，可以做随机元素的获取、弹出，比如说抽奖，也可以做集合类的操作，比如交集、并集和差集等。</font>
5. <font style="color:rgb(51, 51, 51);">zset：zset是一个有序集合，必须指定一个排序的score，可以用来做排行榜。</font>

# <font style="color:rgb(51, 51, 51);">Redis 为什么这么快？</font>
1. <font style="color:rgb(51, 51, 51);">基于内存实现。Redis中的数据是存储在内存中的，所以读写速度很快。在计算机中，各个硬件的访问速度由高到低，依次是：寄存器 > 一级缓存 > 二级缓存 > 三级缓存 > 内存 > 固态硬盘 > 机械硬盘。</font>
2. <font style="color:rgb(51, 51, 51);">采用了单线程 + IO多路复用技术来提高IO利用率。Redis在处理客户端的请求时，从Socket连接建立，到指令的读取、解析、执行、写回，都是在一个串行的主线程中执行的，这就是Redis的单线程模型。Redis6.0后，为了提高性能，把指令的读取、解析和写回这三步IO操作，改为了多线程处理。而执行还是单线程的方式执行的，可以避免上下文切换带来的性能开销，并且不用考虑线程安全问题。而IO多路复用技术，就是多个Socket连接复用同一个线程，也就是单线程能够高效处理多个连接请求的技术。</font>
3. <font style="color:rgb(51, 51, 51);">高效的数据结构。Redis底层是用了SDS/LinkedList/ZipList/HashTable/IntSet/SkipList/Listpack等高效的数据结构，这也是Redis为什么这么快的重要原因之一。</font>

# <font style="color:rgb(51, 51, 51);">为什么 Redis 设计为单线程？6.0 版本为何引入多线程？</font>
<font style="color:rgb(51, 51, 51);">Redis的单线程模型是指，处理网络IO以及读写命令，也就是Socket连接后，指令的读取、解析、执行和写入是由一个线程单独完成的。</font>

<font style="color:rgb(51, 51, 51);">为什么Redis设计为单线程，因为Redis的绝大部分操作是基于内存的，它的主要性能瓶颈不是CPU，而是内存和网络。这就意味着，Redis不需要采用多线程的方式提升CPU的利用率。</font>

<font style="color:rgb(51, 51, 51);">Redis也可以采用多线程来提高IO利用率，但是Redis没有这样做，而是采用IO多路复用技术。</font>

<font style="color:rgb(51, 51, 51);">此外，单线程模型相对于多线程，可维护性更好，更易开发和调试；同时不存在线程安全的问题，也不存在线程的上下文切换带来的性能开销。</font>

<font style="color:rgb(51, 51, 51);">那为什么6.0版本引入多线程呢。</font>

<font style="color:rgb(51, 51, 51);">Redis6.0中的多线程只是针对与网络IO采用了多线程处理，而读写命令的操作还是采用单线程模型进行处理的。6.0前为了提升IO利用率，Redis采用了IO多路复用技术。但是IO多路复用本质仍然时同步阻塞的IO模型。为了更高效的提升网络IO的利用率，Redis6.0引入多个IO线程来处理网络请求，通过网络请求的并发执行，大大提升了Redis的性能。</font>

# <font style="color:rgba(0, 0, 0, 0.88);">Redis 中跳表的实现原理是什么？</font>
跳表是一种基于有序链表的高效数据结构，通过建立多级索引实现快速查询。它在平均情况下支持O(log n)时间复杂度的搜索、插入和删除操作，性能接近于平衡树，但实现更简单。

那么什么是跳表？

+ 调表有多层链表组成，底层存所有元素，上层是下层的子集。
+ 插入操作：从最高层找位置，随机确定新节点层数，插入并更新指针。
+ 删除操作：从最高层找节点，在各层更新指针以保持结构，
+ 查找操作：从最高层开始逐层向下，效率高，时间复杂度为 O(logn)。

# <font style="color:rgba(0, 0, 0, 0.88);">Redis 的 hash 是什么？</font>
Hash是一个键值对集合，可以存储多个字段和值。一个Hash类型的键最多可以存储2∧32 - 1个字段。

特点如下：

1. 适合存储小数据，使用哈希表实现，能够再内存中高效存储和操作
2. 支持快速的字段操作（如增删改查），非常适合存储对象的属性。

Redis的Hash数据类型的底层数据结构为：

+ 当元素个数和元素值得长度都未达到阈值时，Redis7.0之前使用ziplist，之后使用listpack
+ 当元素个数或元素值得长度达到阈值时，会采用字典。

# <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);">Redis Zset 的实现原理是什么？</font>
两种数据结构：压缩表（哈希表）和跳表。

默认情况下，Redis保存的元素个数小于128个，并且保存的所有元素大小小于64节时，使用压缩表。否则就是用跳表。

+ 压缩表是一种紧凑的连续存储的数据结构，它可以将多个元素存储在一篇连续的内存空间中，可以减少内存碎片和额外指针开销。但是压缩表只是用了小规模的有序集合，因为查找和修改上的操作都是线性的，数据体量越大，性能越差。
+ 跳表可以操作效率O(logn)，性能好效率高。但是数据体量小的时候，跳表复杂度高于压缩表，需要维护层级和指针，比压缩表使用了更多的压缩空间。

# <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);">Redis 中如何保证缓存与数据库的数据一致性？</font>
1. 延时双删：先删除Redis缓存数据，再更新MySQL，延迟几百毫秒再删除Redis缓存数据，这样就算在更新MySQL时，有其他线程读了MySQL，把老数据读到了Redis中，那么也会被删除掉，从而把数据保持一致。
2. 队列+重试机制：更新完MySQL后进行删除，如果删除失败则向MQ发送一条消息，然后消费者不断进行删除重试。
3. 异步更新缓存：MySQL中产生了新的写入、更新、删除等操作，就可以把相关的消息推送至Redis，Redis根据binlog中的记录，对Redis进行更新。这个类似与MySQL主备同步的实现，实际方案通过canal中间件，对binlog进行订阅，模仿MySQL从库备份请求，使得Redis数据达到同步更新的效果。

# <font style="color:rgba(0, 0, 0, 0.88);">Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？</font>
+ 缓存击穿：热点数据缓存失效，大量请求直接打到数据库。可以通过设置互斥锁，或者热点数据永不过期来避免。
+ 缓存穿透：查询不存在的缓存数据，缓存无记录，请求直接打到数据库。可以通过使用布隆过滤器来避免。
+ 缓存雪崩：多个缓存数据同时过期，大量请求打到数据库。可以通过设置随机过期时间，以及双缓存策略来避免。

# <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);">Redis String 类型的底层实现是什么？（SDS）</font>
String类型的底层实现是SDS（simple dynamic string）

SDS有三种编码类型：

+ embstr：存储小于等于44字节的字符串数据
+ raw：存储大于44字节的字符串数据
+ int：存储整型数据

结合以上三种不同的编码方式进行优化存储。

#  <font style="color:rgba(0, 0, 0, 0.88);">Redis 中如何实现分布式锁？</font>
在Redis中实现分布式锁。

通常使用SET NX（SET if Not eXists）命令，该命令只有在key不存在时才会设置key的值，使用SET NX可以确保在分布式环境下只有一个客户端能够获得锁。使用SET NX实现分布式锁的步骤如下：

1. 尝试使用SET NX命令设置key的值，如果设置成功，则表示获得了锁，可以进行后续操作。
2. 如果SET NX命令返回0，则表示key已经被其它客户端设置了值，则表示无法获得锁。
3. 在完成操作后，需要使用DEL命令删除key的值，释放锁。
4. 需要注意的是，使用SET NX命令设置key的值时，可以将当前时间作为value的值，并记录变量，然后在释放锁时判断时间变量是否与value的值相等，以保证锁的有效性。另外，为了避免锁无法释放的情况，可以通过EXPIRE命令设置一个过期时间。

# <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);">Redis 的 Red Lock 是什么？你了解吗？</font>
Redis RedLock（红锁）是一种分布式锁算法，旨在解决传统单节点Redis锁在分布式环境中的可靠性问题。其核心思想是通过多个独立的Redis节点协同工作，以降低单点故障风险，确保锁的高可用性和强一致性。

**RedLock 核心原理**

1. 部署架构：需要至少5个（推荐奇数个）完全独立的Redis主节点（无副本关系），部署在不同物理/虚拟机上，避免共因故障。
2. 加锁流程
    1. 步骤1：客户端获取当前时间戳 T1
    2. 步骤2：依次向所有Redis节点发送加锁命令（SET key random_value NX PX timeout）
    3. 步骤3：计算获取锁的总耗时 T2 = 当前时间 - T1
    4. 步骤4：若满足以下两个条件，则认为加锁成功
        1. 成功获得半数以上（N/2 +1）节点的锁；
        2. T2 < 锁的有效时间（TTL）

# <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);">Redis 实现分布式锁时可能遇到的问题有哪些？</font>
| <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);"> 问题 </font> | <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);"> 描述 </font> | <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);"> 解决方案</font> |
| --- | --- | --- |
| 锁到期问题 | 如果设置的锁的有效时间（TTL）过短，可能会导致锁在业务逻辑执行完成之前就自动过期，从而导致其他客户端获取到锁，引发数据不一致的问题。 | 1. 合理设置 TTL：根据业务逻辑的执行时间合理设置锁的有效时间。<br/>2. 自动续期机制（Watchdog）：在锁的有效时间内定期延长锁的过期时间，确保锁不会提前过期。 |
| 单点故障问题 | 使用单节点 Redis 时，若 Redis 宕机或不可用，分布式锁将无法正常工作，影响业务的正常执行。 | 1. 使用 Redis 哨兵模式或集群模式，提升 Redis 的高可用性。<br/>2. 使用 RedLock 算法，确保在多个节点中至少半数成功加锁后才认为加锁成功。 |
| 主从数据同步问题 | 在 Redis 集群中，如果主节点发生故障，从节点可能会接管主节点的角色，但此时从节点可能没有最新的锁信息，导致锁数据丢失。 | 1. RedLock 算法：通过在多个独立的 Redis 节点上同时获取锁，提高系统的可用性和可靠性。 <br/>2. WAIT 命令：在写入数据后，使用 WAIT 命令确保数据已经同步到指定数量的从节点。 |
| 网络分区问题 | 网络分区(脑裂)导致不同节点可能获取相同的锁，从而出现分布式系统的不一致性。 | 1. 在 RedLock 的网络分区场景下，锁的不一致风险虽存在，但实际概率较低。<br/>2. 对于一致性要求较高的场景，可引入 Zookeeper 等一致性算法来增强可靠性。 |
| 时钟漂移问题 | 不同节点之间的时钟可能存在偏差，这会导致锁的有效时间计算不准确，从而影响锁的正确性。 | 1. 使用 NTP 同步：确保所有节点的时钟同步，减少时钟漂移的影响。 <br/>2. 冗余时间余量：在设置锁的有效时间时，预留一定的冗余时间，以应对时钟漂移。 |
| 误解锁问题 | <font style="color:rgba(6, 8, 31, 0.88);">错误地释放不属于自己的锁，导致锁状态异常。</font> | 1. 加锁时存储持有者信息(如线程 ID 或业务标识)，解锁时校验是否一致。<br/>2. Redisson 库支持该功能，推荐直接使用。 |
| 可重入性问题 | <font style="color:rgba(6, 8, 31, 0.88);">如果一个线程需要多次加锁且能正确解锁(即锁可重入)，实现不当可能导致死锁或加锁失败。</font> | 1. 使用 Redis 加锁时记录重入计数和线程 ID，确保加锁几次就需解锁几次。<br/>2. 直接使用 Redisson 可避免手动处理复杂逻辑。 |


# <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);">Redis 的持久化机制有哪些？</font>
为了解决数据存储在内存中容易丢失的问题，Redis提供了两种持久化策略，RDB和AOF。

+ RDB持久化：在指定的时间间隔内，把内存中的数据集快照写入磁盘，也就是只保留某个时间点的数据。
+ AOF持久化：记录服务器接受的所有写操作命令，并且将这些命令追加到记录文件里，持久化到磁盘上。在服务器执行的时候，通过重新执行这些命令来还原数据。

**RDB：**

+ 优点：恢复大数据集的速度比AOF快，对CPU和内存的影响较小，适合需要做冷备份和对数据恢复要求不高的场景。

**AOF：**

+ 优点：更加稳定，数据的完整性更好，适合用于对安全性要求较高的场景，比如购物车、订单等关键业务。



实际使用中，RDB和AOF可以混用。

# <font style="color:rgba(0, 0, 0, 0.88);">Redis 主从复制的实现原理是什么？</font>
Redis主从复制是指在Redis集群里，Master节点与Slave节点数据同步的一种机制。Redis提供了全量复制和增量复制两种模式，全量复制一般发生在Slave节点初始化的阶段。增量复制就是变更过程中，把Master节点变更数据同步到Slave节点中。

+ 全量复制：从节点主动向主节点发起同步请求，主节点收到请求后会生成一份数据快照发送给从节点，从节点收到数据进行加载后，完成全量复制。
+ 增量复制：主节点把变化的增量数据同步给从节点，通过维护offset这样一个复制偏移量来实现。

# <font style="color:rgba(0, 0, 0, 0.88);">Redis 数据过期后的删除策略是什么？</font>
过期删除策略一共有三种，定时删除、定期删除和惰性删除。定时删除和定期删除是主动的，惰性删除是被动的。

+ 定时删除：为设置过期时间的键创建一个定时器，使用定时器，可以定时删除过期的一个键值对，释放内存空间。但是大量的定时器执行，会占用一部分CPU。CPU紧张时，会影响Redis的响应时间和吞吐量。
+ 惰性删除：放任过期的键不管，每一次获取键才检查进行过期删除，这样的策略若存在大量长时间不访问的数据，会对内存不友好。
+ 定期删除：每隔一段时间检查部分键是否过期，然后进行删除。这种情况下可以自定义删除的频率和执行时长，但是确定频率和执行时长是麻烦的。

# <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);">如何解决 Redis 中的热点 key 问题？</font>
1. 本地缓存，使用本地缓存来缓解Redis的压力，从而减少对热key的直接访问。
2. 请求分摊，把热key拆分成多个子key，这样可以将读请求分摊到多个key上，从而降低单key的压力。
3. 限流，对热key的访问进行限流，防止过多请求进入。
4. 监控和报警，通过设置监控来实时观测Redis的使用情况，及时应对热key问题，例如通过Redis的INFO命令或使用监控工具。对于不可预知的热key场景，可以接入热点探测系统等，定期上报key调用次数，检测是否热key，然后通过sdk通知各个节点构建缓存来解决热key问题。

# <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);">Redis 集群的实现原理是什么？</font>
Redis集群是一种用于实现高可用和可伸缩性的分布式系统，把数据分片存储在多个节点上，从而允许在多个服务器上扩展数据容量和负载，每个节点都负责存储一部分数据，并与其它节点进行通信协作。

Redis集群的主要原理如下：

1. 数据分片：Redis集群使用了哈希槽(hash slot)的概念将所有的可能键分成16384个哈希槽。每个节点负责处理其中一部分槽的数据，通过数据的哈希值来确定它应该属于哪个槽。
2. Gossip协议：Redis集群中的每个节点通过Gossip协议进行通信，节点之间相互广播关于自身状态的信息，包括集群配置、节点状态、槽的分配等。这样所有节点都可以了解到整个集群的状态，并及时感知到其他节点的变化。
3. 主从复制：每个节点都可以有多个从节点，从节点复制主节点的数据，实现数据的备份和故障转移。在主节点宕机时，从节点会自动选举出新的主节点
4. 客户端路由：客户端与Redis集群进行交互时，需要通过Redis-Cluster客户端库与集群的某个节点建立连接。客户端根据键的哈希值来决定将请求发送到哪个节点上，节点再负责处理相应的槽中的数据。

# <font style="color:rgba(0, 0, 0, 0.88);background-color:rgb(250, 250, 250);">Redis 中的 Big Key 问题是什么？如何解决？</font>
Redis的大Key问题是指单个Key所对应的数据量过大，一般单个key超过10kb就被认为是大Key，这会导致以下问题：

1. 网络延迟增大：传输大数据需要更多的时间。
2. 阻塞Redis性能：大Key的操作会阻塞Redis单线程的性能。
3. 内存不足和导致OOM：大Key可能会占用过多内存，影响其它部分的缓存使用，

为了解决这些问题，可以采取以下解决方案：

1. 分拆大key
    1. big list：对列表进行分片分页
    2. big hash：将数据分段存储，比如1百万的用户数据，拆分成200个key，每个key下5000个用户数据。
2. 压缩数据：在存储之前对较大的数据进行压缩，从而减少存储占用空间。
3. 惰性删除：当更新或删除大key时，使用惰性删除，来避免阻塞整个redis。
4. 使用scan替代keys，在处理集合时，使用scan命令遍历大key而不是keys，避免一次性加载所有数据。

