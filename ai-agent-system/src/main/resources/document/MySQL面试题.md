# MySQL的存储引擎有哪些？
**开头：** 通过MySQL官网可以了解到，MySQL提供了10个存储引擎，包括InnoDB、MyISAM、memory等。我主要讲一下最常用重要的两个存储引擎吧，分别是InnoDB和MyISAM。

**默认引擎：** InnoDB，是MySQL5.5版本后的默认引擎。MySQL5.5版本前，默认引擎是MyISAM。

**InnoDB是什么：** InnoDB是一种事务性的引擎，适合高并发和事务需求大的场景。

**InnoDB的存储结构和存储空间： ** InnoDB的存储结构为表定义文件（.frm）和索引数据文件（.ibd）。那么这种存储结构，索引和数据是存储同一个文件里的，索引b+树上的叶子节点就会存储整个数据行所有的数据。这种情况下，单个表的大小受限于操作系统单个文件的大小，一般是2G。

**MyISAM是什么：** MyISAM则是非事务性的存储引擎，适合只读或者低并发写入的场景，例如数据仓库等。

**MyISAM的存储结构和存储空间：** iMyISAM的存储结构为表定义文件（.frm）、索引文件（.myi）、数据文件（.myd）。这种存储结构就是将索引和数据分开存储，索引b+树上的数据存储的地址，根据索引查找到对应数据地址，根据地址获取到相应的数据。这种情况下，MyISAM具有静态表，动态表，压缩表等，支持对表压缩，有效节省存储空间。

**其他区分点：** 除此之外，InnoDB支持外键，支持行锁，有更细粒度的锁机制。而MyISAM不支持外键，且只有表锁，不支持行锁，所以对MyISAM存储引擎的表进行写操作时无法拥有很好的并发性能，性能消耗大。

**综上：** InnoDB和MyISAM大概可以总结为5个区分点：存储结构、存储空间、事务支持、锁支持和外键支持。

# InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？
**开头：**聚簇索引和非聚簇索引是InnoDB引擎中两种不同的索引类型，以下是这两种索引的主要区别点。

**聚簇索引**

聚簇索引是根据主键值物理排列数据行的索引类型。一般是表的主键，或者第一个非null的唯一索引，再或者虚拟的行主键。一个表只能有一个聚簇索引。

聚簇索引以B+树构建，叶子节点即为完整行数据。索引是按照主键值排序的，所以数据行的储存顺序与索引顺序一致。在这种条件下，聚簇索引适合按顺序范围查询，因为数据是是物理上连续存储的。当查询对应主键索引时，能直接从叶子节点上获取行数据，减少回表操作。但同时也带来一些缺点，主键列较长会导致索引占用空间大。并且修改主键值，或者新数据写入，都需要维护顺序。这两个缺点都增加了资源的损耗，降低性能。

**非聚簇索引**

非聚簇索引是独立于数据行存储的索引类型。一个表可以有多个非聚簇索引。

非聚簇索引也是以B+树构建，叶子节点存储的是主键值。这种条件下，根据非聚簇索引查询数据时，需要多一次查询，也就是回表查询，拿到对应的主键值，再到聚簇索引获取完整数据行。但支持多非聚簇索引，可以实现覆盖不同情况下的查询优化。非聚簇索引的缺点也显而易见，每次查询都需要回表查询，增加查询时间。多个非聚簇索引，每个都需要单独存储空间的情况下，会占用更多存储空间。

# MySQL 的索引类型有哪些？
**基于数据结构角度**

B+树索引：基于树形结构储存，是MySQL默认的索引类型，常用于InnoDB和MyISAM。

哈希索引：基于哈希表结构储存，常用于Memory引擎，哈希结构不存储数据顺序。

倒排索引：用于大文字段的全文关键字搜索

R-树索引：转为空间数据设计，常用于存储和查询GIS中的空间数据。

**基于InnoDB B+树索引角度**

聚簇索引、非聚簇索引

**基于索引性质角度**

普通索引、主键索引、联合索引、唯一索引、全文索引、空间索引

# 为什么 MySQL 选择使用 B+ 树作为索引结构？
首先常见的数据库存储引擎一般采用采用B树或B+树来作为索引结构。B树是一种多路平衡树，在存储大量数据的情况下，层高比二叉树要少，由于树的高度能决定磁盘IO次数，也就提高了数据库在磁盘IO上的效率，提高性能。而B+树是对B树的一个增强结构。

B+树的特点：

1. B+树的所有数据都存储在叶子节点，非叶子节点只存储索引
2. 叶子节点中的数据使用双向链表的方式进行关联

基于以上两个特点，我认为MySQL选择B+树作为索引结构有以下原因：

1. 非叶子节点不存储数据，所以每一层能够存储的索引数量会增加，意味着与B树在层高相同的情况下，**存储数据量要多，并且磁盘IO更少**。
2. 对于MySQL常用范围查询有更好的性能，B+树所有存储在叶子节点的数据都用了双向链表关联，查询时只需查两个节点进行遍历即可。相对于B树在查询时需要获取所有节点，**B+树全局扫描能力更强，IO次数更稳定，查询效率更高**。
3. 基于B+树结构，在采用自增整型数据作为主键时，能更好**避免在新增数据的时候，带来叶子节点分裂，导致大量运算的问题**。

# MySQL 三层 B+ 树能存多少数据？
三层 B+ 树能存多少数据，取决于索引大小、数据页大小等因素。

在MySQL中，B+树的每个节点都是一个数据页，数据页默认大小是16kb。非叶子节点存储的是多个索引值以及页的偏移量，叶子节点存储的是完整的多行数据。

假设一行数据大小是1k，那么一页就可以放16条数据。再假设主键id为bigint类型，长度为8字节，指针大小在InnoDB中占6个字节。可得每页的指针数量为16384/(8+6) = 1170个指针。

一个指针可以指向一个存放记录的页 ，一个页存放的数据可以有16条。高度为2的B+树就可以存放1170x16 = 18720条数据，同理高度为3的B+树就可以存放1170x1170x16 = 21902400条数据。

综上，B+树在2到4层就可以满足，千万级别的数据量存储，当基于主键查询时，只需要2到4次的磁盘IO。

# MySQL 索引的最左前缀匹配原则是什么？
最左匹配原则指的是索引的匹配方式，简单来说，当查询语句中有多个条件，并且这些条件可以使用索引进行匹配时，数据库系统会使用最左匹配原则来选择最合适的索引进行查询。以下举个例子

如果有索引（a, b, c, d），查询条件a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。先匹配最左边的，索引只能用于查找key是否存在（相等），遇到范围查询（>，<， between，like左匹配）或者跳过某一个索引条件等情况就不能进一步匹配了，后续退化为线性查找。

**总结**：最左前缀匹配原则要求查询条件必须从索引的第一列开始匹配，严格按照索引的字段顺序进行，否则后续字段的条件无法通过索引优化。

# MySQL 中的回表是什么？
回表就是，当我们使用非聚簇索引查询数据时，可能还需要查询非聚簇索引的其他列，但走的索引树叶子节点只能查到当前列以及主键ID，所以需要根据主键ID再去查一遍数据，得到所需的其他列。

回表会带来随机IO，频繁回表效率非常低。想要避免回表，可以使用覆盖索引，也就是覆盖了所有查询列的联合索引。

# 在 MySQL 中建索引时需要注意哪些事项？
1. 避免盲目建索引，要控制索引数量。索引并不是越多越好，每个索引都占用了一定的空间，并且修改数据时需要维护索引，进而消耗了系统资源。
2. 考虑表修改频率，当修改频率高，远大于查询频率时，不建索引，因为建索引会拉低修改效率。
3. 特定操作字段建索引，比如对order by，group by，distinct后的字段建索引，可以加快排序、分组和去重速度。
4. 选择适合字段建索引，对于高重复值的字段，如果值分布均匀如性别字段，是不建议建索引的，但若是分布差距大，如任务状态的字段，是可以建索引提高筛选查询速度。另外长字段不建议建索引，可能会降低性能。
5. 频繁查询字段建索引，经常用作条件查询的字段，可以建立索引，多个条件可以建立联合索引，可以提高查询效率。

# MySQL 中使用索引一定有效吗？如何排查索引效果？
**MySQL中使用索引不一定有效** ，索引的作用是提高查询效率，但如果索引使用不当或者MySQL选择了错误的执行计划，索引反而可能会失效，甚至降低性能。以下情况下，MySQL可能不会使用索引，例如：

+ 小表数据量太少，全表扫描比索引查询更快。
+ 索引字段变更、或使用函数、计算，如 where YEAR(create_time) = 2025 会导致索引失效、以及不符合最左前缀匹配原则的查询条件
+ 查询返回数据太多，索引加速作用有限，MySQL可能会选择全表扫描。

**如何排查索引效果：**

可以通过MySQL的执行计划来查看，执行explain{SQL语句}，主要观察以下几个点：

+ type（访问类型）：这个属性显示了查询的使用方法，例如all、index、range等。all是全表扫描，也就是没用上索引。后面两个就是用上了索引。
+ key（使用的索引）：这个属性显示了查询使用的索引，如果显示为NULL，即是没有使用索引。
+ rows（扫描的行数）：这个属性显示了查询扫描的行数，如果这个值很大，可能表示查询使用了全表，并没有使用索引。

# MySQL 中的索引数量是否越多越好？为什么？
索引数量不是越多越好，索引都要占用空间，越多占用空间。而且增删改操作下，由于要维护数据页和索引页之间的顺序，索引越多，耗费时间越长。并且查询数据时，如果索引越多，会导致MySQL优化器要耗费更多时间在选择决策查询方案上。

# 如何使用 MySQL 的 EXPLAIN 语句进行查询分析？
执行explain{SQL语句}，会返回查询的执行计划信息，包括涉及的表、索引的使用情况、扫描方式等。如果是执行explain fotmat = json {SQL语句} 会返回结构化的json信息。

返回输出的字段解释如下

| 字段名 | 说明 |
| --- | --- |
| id | 查询中每个操作的标识符，查询的执行顺序从大到小。 |
| select_type | 查询类型，如简单查询、子查询、联合查询等（SIMPLE、PRIMARY、SUBQUERY 等）。 |
| table | 当前查询操作涉及的表名。 |
| partitions | 表示使用的分区（如果有分区表）。 |
| type | 访问类型，表示查询操作的效率，类型从好到差依次为：system > const > eq_ref > ref > range > index > ALL。 |
| possible_keys | 查询可能使用的索引。 |
| key | 查询实际使用的索引。 |
| key_len | 使用索引的字节长度，反映索引使用的精确性。 |
| ref | 表示使用索引的比较列。 |
| rows | MySQL 估计需要扫描的行数，行数越少，查询性能越高。 |
| filtered | 表示返回结果占扫描行数的百分比，值越大越好。 |
| Extra | 额外信息，如 Using index（覆盖索引）、Using where（条件过滤）、Using temporary（临时表）。 |


# MySQL 中如何进行 SQL 调优？
1. 使用 EXPLAIN 分析查询
2. 创建和使用合适的索引
3. 优化查询语句
4. 优化表结构，选用合适的数据类型。对于大数据表，可以考虑分区表，分表归档等。
5. 使用缓存
6. 监控和分析慢SQL日志
7. 优化服务器配置，调整缓冲池大小、线程池大小等。

# 请详细描述 MySQL 的 B+ 树中查询数据的全过程
数据从根节点找起，根据键值的大小确定是左子树还是右子树，从上到下最终定位到叶子节点。定位到叶子节点后，因为节点默认有16k大小，所以理论上可以存多条数据。

而叶子节点有页目录结构，其实就是一个索引，通过它可以快速找到记录。页目录分为了多个槽，每个槽都指向对应一个分组内的最大记录，每个分组内都会包含若干条记录。通过二分查询，利用槽就能直接定位到记录所在的组，从而就能获取到对应的记录。

# MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？
1. count(1)
    - 功能：统计表中行的数量，包含所有行，无论行中的值是什么
    - 工作原理：每一行以常数1进行计算，即对于每一行都会计数一次，因此它的计算与count(*)基本相同。
    - 效率：在某些数据库实现中，count(1)的性能可能与count(*)相同，因为二者在功能上是等效的。
2. count(*)
    - 功能：统计表中所有行的数量，包括所有列，无论列的值是否为null
    - 工作原理：按行统计时，不考虑列的具体值和数据类型
    - 效率：是最常用的方法之一，特别在InnoDB引擎中，count(*)通常时最优的计数形式，因为它被优化为直接统计数据页上的数目。
3. count(字段名)
    - 功能：统计指定列中非NULL值的行数
    - 工作原理：只计数该列中有非NULL的值。因此，如果某行在该字段中的值为NULL，即不会被计入总数。
    - 场景：用于需要过滤掉NULL值时

性能对比：count(*) ≈ count(1) > count(字段名)

大多数情况下可用count(*)，因为它清晰明了并且通常时经过优化的了。当特殊需要统计非NULL列行数，可以用count(字段名)

# MySQL 中 varchar 和 char 有什么区别？
char是一个固定长度的字符串，而varchar是一个可变长度的字符串。

存储效率不同，char类型每次修改后存储空间的长度不变，所以效率更高。而varchar每次修改数据都需要更新存储空间长度，效率较低。

存储空间不同，char不管实际数据大小，存储空间是固定的，而varchar的存储空间是等于实际数据长度，所以varchar的存储空间利用程度比char更高。

char适合存储较短且固定长度的字符串，varchar适合存储可变长度的字符串。

# MySQL 是如何实现事务的？
MySQL的事务满足ACID特性，即原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。

所以MySQL如何实现事务的，就是InnoDB如何保证ACID特性的过程。

首先，原子性，保证多个DML操作的原子性，要么都成功要么都失败，而失败时需要回滚。所以InnoDB设计了一个UNDO_LOG表，在事务执行的过程中，把修改之前的数据快照保存到UNDO_LOG里。一旦出现错误，就直接从UNDO_LOG里读取原先数据进行反向操作即可。

其次，一致性，保证数据的完整性约束，这个更多依赖于业务层面上的保障。MySQL也提供了不同约束，比如像主键的唯一约束，不同的字段长度和类型来保障。

接着，隔离性，保证并行事务对同一个操作进行操作时不互相干扰，不导致数据混乱的问题。InnoDB提供了四种隔离级别的实现，分别是RU（未提交读）、RC（已提交读）、RR（可重复读）和Serializable（串行化）。InnoDB默认默认采用RR，然后采用MVCC机制去解决了脏读和不可重复读的问题，并且使用行锁或表锁的方式来解决幻读的问题。

最后，持久性，只要事务提交成功，数据影响即是永久的，不会因为数据库宕机或其他原因导致数据变更的失效。理论上来说，事务提交后，将数据写入磁盘即可，但是随机磁盘的IO效率很低，所以InnoDB设计了Buffer Pool缓存区来进行优化。也就是数据发生变化时，先更新内存缓冲区，然后在合适的时间再持久化到磁盘里面。但这个过程容易发生数据库宕机，导致持久化失败的情况。所以InnoDB设计引入了REDO_LOG文件，该文件存储了变更后的值，是和内存缓冲区同步更新的，数据库会直接将文件内的数据写入到磁盘里实现持久化。所以当数据库宕机时，重启后可根据REDO_LOG文件去进行重写。

# MySQL 中的 MVCC 是什么？
MVCC是多版本并发控制，主要解决数据库并发问题，包括读读操作，读写操作以及写写操作。读读操作不存在线程安全问题，读写操作存在事务隔离性问题，可能会发生脏读、幻读和不可重复读等，而写写操作可能会发生更新丢失的问题。

MVC允许多个事务同时读取写入数据库，而无需互相等待，提高数据库并发性能。

mvcc解决的就是读写时的线程安全问题，线程不用去争抢读写锁。在MVCC中，数据库为每个事务都创建了一个数据快照，每当数据被修改时，MySQL不会立即覆盖原有数据，而是生成新版本的记录。每个记录都保留了相应的版本号或时间戳。

mvcc所提到的读是快照读，也就是普通的select语句。快照读在读写时不用加锁，不过可能会读到历史数据。

还有一种读取数据的方式是当前读，是一种悲观锁的操作。它会对当前读取的数据进行加锁，所以读到的数据都是最新的。主要包括以下几种操作：

+ select lock in share mode（共享锁）
+ select for update（排他锁）
+ update（排他锁）
+ insert（排他锁）
+ delete（排他锁）

# MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？
**日志类型**

归属于MySQL服务层：

+ showlog 慢sql记录
+ binlog 主从同步
+ errorlog 错误信息
+ relaylog 从节点暂存主节点同步过来的binlog数据

归属于引擎层，InnoDB特有：

+ undolog 回滚日志
+ redolog 前滚日志

# MySQL 中的事务隔离级别有哪些？
事务隔离级别是为了解决多个并行事务竞争导致的数据性安全性问题的一种规范，

具体来说，多个事务竞争可能会出现三种不同的现象：

1. 假设两种事务T1、T2同时执行，T1可能会读取到T2事务未提交的数据，但是T2可能会回滚，导致产生一个脏读现象。
2. 假设两种事务T1、T2同时执行，T1在不同的时刻读取同一行数据的时候，结果可能不一样，导致产生不可重复读现象。
3. 假设两种事务T1、T2同时执行，T1执行范围查询或范围修改的过程中，T2插入一条属于T1操作范围数据并提交，T1的操作，就会产生多一条数据，或者多一条数据未修改，导致产生幻读现象。

所以MySQL InnoDB实现了四种隔离级别，分别是RU（未提交读）、RC（已提交读）、RR（可重复读）和Serializable（串行化）。InnoDB默认默认采用RR，以此保证ACID中的I 隔离性。

RU隔离级别下可能会产生脏读、不可重复读和幻读。

RC隔离级别下可能会产生不可重复读和幻读。

RR隔离级别下可能会幻读。

Serializable隔离级别下不会产生安全性问题，但性能也最低。

# MySQL 默认的事务隔离级别是什么？为什么选择这个级别？
基于历史和技术考虑，MySQL默认的事务隔离级别是RR。

MySQL主从复制是通过binlog日志进行数据同步的，而在早期的版本中binlog记录的是SQL语句的原文。这个时候，如果binlog格式设置为statement格式时，MySQL可能会在从库执行SQL的逻辑与主库不一致。比如：

```plain
delete from tb_user where a >= 13 and b <= '2024-04-21' limit 1;
```

**为什么会不一致呢**

+ 主从库使用的索引可能不一致。由于MySQL优化器在不同的库里采样计算的结果不一样，会影响优化器的判断，进而影响索引的选择。
+ 由于该条语句用了limit，但没有规定顺序，排序可能不一致，所以会出现主备数据不一致的情况。
+ 另外，RC和RU是不会添加Gap Lock间隙锁的。而主从复制过程中出现的事务乱序的问题，更加容易导致主备库发生回滚后产生不一致的现象。

为了解决以上不一致的问题，MySQL选择了RR作为默认隔离级别。可重复读隔离级别，在更新数据时会增加记录锁和间隙锁，可以避免事务乱序导致的数据不一致问题。

# MySQL 中有哪些锁类型？
1. 行级锁：锁定特定行，允许多个事务并发访问不同的行，适用于高并发场景。
2. 表级锁：锁定整个表，其他事务无法对表进行任何读写操作，适用于需要保证完整性的小型表。
3. 意向锁：表示加锁意图，分为意向共享锁（IS）和意向排他锁（IX），用于行级锁和表级锁的结合。
4. 共享锁：允许多个事务读取，不允许修改，释放后其它事务才能获得排它锁。
5. 排它锁：仅允许一个事务读写，其它事务无法访问该资源。
6. 元数据锁：保护数据库对象元数据，防止在进行DDL操作时其他事务修改对象。
7. 间隙锁：锁定索引间隙，防止其他事务在间隙中插入新纪录，避免幻读。
8. 临建锁：结合行级锁和间隙锁，锁定具体行和其前面的间隙，确保一个范围内部会出现幻读。
9. 插入意向锁：等待间隙的锁，只是事务打算在某个间隙中插入记录，允许共享锁，阻止排他锁。
10. 自增锁：保证自增值的唯一，防止并发插入导致的冲突，通常在插入操作时使用。
11. 谓词锁：支持空间索引，用于处理涉及空间索引的操作，防止插入或修改与查询条件匹配的行。

# MySQL 事务的二阶段提交是什么？
当MySQL开启了binlog日志的情况下，MySQL事务提交时，需要同时完成redolog和binlog的事务写入。redolog是事务日志，binlog是数据库变更的逻辑日志，这是两个独立的写入磁盘的动作，并且两个操作都要成功。而为了保证两个日志内容的一致性，需要用到两阶段的提交机制。

MySQL的二阶段提交发生在redolog和binlog的日志写入阶段，也就是把日志写入和日志提交拆分为两个阶段来确保redolog和binlog写入数据的一致性。第一阶段是prepare阶段，本阶段MySQL会将事务操作记录到redolog中并标记为prepare状态。第二阶段是commit阶段，当事务提交时，MySQL会将事务操作记录到binlog中。然后把redolog中的日志设置为commit状态。

# MySQL中解决死锁的办法
+ 自动检测和回滚
    1. 自动死锁检测：MySQL自带死锁检测机制（innodb_deadlock_detect），检测到死锁时，自动回滚持有最少资源的事务。
    2. 锁等待超时：设置锁等待超时参数（innodb_lock_wait_timeout），超过等待阈值时，释放锁并回滚事务。
+ 手动处理死锁
    1. 查找阻塞事务，使用命令找出被阻塞的事务及线程ID。
    2. 手动kill线程，及时释放资源。
+ 避免死锁的手段
    1. 拆分大事务，将大事务拆分为多个小事务，快速释放锁，降低死锁概率。
    2. 调整锁申请顺序，保证获得足够的锁。先获取影响范围大的锁，如排他锁。
    3. 更改数据库隔离级别，可重复性比读已提交多了间隙锁和临键锁，利用替换读已提交可降低死锁。
    4. 合理建立索引，减少加锁范围，命中索引则锁对应行，否则全表加锁。
    5. 开启死锁检测，适当调整锁等待时长。

# MySQL 中如何解决深度分页的问题？
深分页问题是指当limit偏移量较大时，MySQL查询性能显著下降。这是因为MySQL可能选择全表扫描而而非索引扫描，导致查询效率低。

例子：select * from user limit 10000, 5;

实际上这条语句，是扫描了10000+5条数据，把前面的10000条数据过滤掉，再留下来10001~10005的数据。

这个要优化解决深分页的问题，主要可以分为以下三种：

1. 记录id，每次查询时带上一次查询的id，就可以利用id > maxId去查询，类似于游标查询，跳页的话就不生效了。
2. 可以内连接，先 select id from user limit 10000, 5，再拿这个结果去内连接，回表查询一次，那么扫描的数据会少很多。
3. 从业务层面解决，在应用层面提供更多的筛选方式，避免触及深分页问题。

# 什么是 MySQL 的主从同步机制？它是如何实现的？
在MySQL中，主从复制是一种常用的同步机制，它允许将一个MySQL数据库服务器（主服务器）的数据复制到一个或多个MySQL数据库服务器（从服务器）。主从复制可以用于读写分离、备份、负载均衡等场景。

**实现流程：**

1. 数据变更写入binlog文件中，提交事务后，数据进行本地更新，主库会创建一个log dump线程，用来发送binlog文件。
2. 从库开启同步后，会开启一个io线程，用来请求接收dump线程发送的binlog更新，然后存入从库的relay log中，从库返回一个“复制成功”的响应给主库。
3. 从库创建一个用于重放binlog的线程，去读取relay log，回放其中存储的数据，最终实现主从的数据一致性。

# 如何处理 MySQL 的主从同步延迟？
当数据库主库有较大更新并发操作时，可能会造成主从同步延迟。因为从库里读取binlog的线程只有一个，当某个SQL在从库上执行的时间稍长或者由于某个SQL要进行锁表就会导致主从同步延迟。

主从同步延迟的解决方法常见如下：

1. 写操作后的读操作指定发给数据库主库
2. 读从库失败后再读一次主库，从库查不到就去查主库
3. 关键业务读写全部指向主库，非关键业务采用读写分离
4. 使用缓存，主库写入后同步到缓存，这样可以先查缓存

